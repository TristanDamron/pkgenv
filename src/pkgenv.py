from yaml import safe_load, dump
from os import environ, path, mkdir, getlogin, system, walk, remove, rmdir
from subprocess import Popen, DEVNULL, PIPE
from platform import freedesktop_os_release
from random import randrange
from re import sub

user_home_path = '/home/{}'.format(getlogin())
dot_pkgenv = '{}/.pkgenv'.format(user_home_path)
config_yaml_path = '{}/config.yaml'.format(dot_pkgenv)


def does_package_environment_exist(name):
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return False
    if not config_yaml_dict['custom_environment_paths']:
        return False

    for path in config_yaml_dict['custom_environment_paths']:
        if name == path.split('/')[-1]:
            return True
    return False


def get_default_package_manager_for_distro():
    system_ident = freedesktop_os_release()
    if 'ubuntu' in system_ident['ID'] or 'debian' in system_ident['ID']:
        return 'apt-get'
    elif 'opensuse' in system_ident['ID']: 
        return 'zypper'
    elif 'arch' in system_ident['ID']:
        return 'pacman'
    elif 'alpine' in system_ident['ID']:
        return 'apk'
    return ''


def create_yaml_config_from_template():
    config_yaml_template = """
    default_environment_path: {}

    custom_environment_paths: []

    active_package_environment: default_environment_path

    system_package_managers: [{}]

    preferred_editor: 
    """.format(environ['PATH'], get_default_package_manager_for_distro())
    with open(config_yaml_path, 'w') as f:
        config_yaml = safe_load(config_yaml_template)
        dump(config_yaml, f)


def generate_semiunique_environment_name():
    adjectives = ['smelly', 'funny', 'terrible', 'handsome', 'beautiful', 'ugly', 'giddy', 'fast', 'slow', 'boring', 'serious', 'spiky']
    animals = ['elephant', 'penguin', 'girrafe', 'horse', 'walrus', 'toucan', 'cat', 'dog', 'hamster']
    number = randrange(1, 99)
    return '{}-{}-{}'.format(adjectives[randrange(0, len(adjectives) - 1)],
                             animals[randrange(0, len(animals) - 1)], number)


def does_config_yaml_exist():
    if not path.exists(config_yaml_path):
        return False
    return True


def get_config_yaml_as_dict():
    if not does_config_yaml_exist():
        print('ERROR: Cannot load {}! Have you run `pkgenv create`?'.format(config_yaml_path))
        return None 
    return safe_load(open('{}'.format(config_yaml_path), 'r'))


def write_config_yaml_from_dict(d):
    try:
        with open('{}'.format(config_yaml_path), 'w') as f:
            dump(d, f)
        return True
    except:
        return False


def create_package_environment(name):
    use_auto_generated_environment_name = True if not name else False

    if name == 'default':
        print('ERROR: `default` is protected. Choose another name for your package environment.')
        return False

    if use_auto_generated_environment_name:
        print('WARN: Creating a new package environment without a unique name is not encouraged, particularly ' + 
              'for systems with many package environments. Consider using `--name` next time.')
        name = generate_semiunique_environment_name()
    if not does_config_yaml_exist():
        print('LOG: No config.yaml file present in ~/.pkgenv, creating one now...')
        mkdir(dot_pkgenv)
        mkdir('{}/envs'.format(dot_pkgenv))
        create_yaml_config_from_template()
        print('LOG: Success! Wrote {}'.format(config_yaml_path))
        print('HINT: You can edit this config file at anytime by executing `pkgenv config`!')

    if not use_auto_generated_environment_name and path.exists('{}/envs/{}'.format(dot_pkgenv, name)):
        print('ERROR: Cannot create `{}`, package environment already exists!'.format(name))
        return False
    elif use_auto_generated_environment_name:
        tries = 0
        while path.exists('{}/envs/{}'.format(dot_pkgenv, name)):
            if tries == 5:
                print('ERROR: Tried to create a new package environment with an autogenerated name and failed 5 times ' +
                      'because those names were already taken by other package environments on the system. Try running this ' +
                      'command with `--name` instead.')
                return False 
            name = generate_semiunique_environment_name()
            tries += 1

    mkdir('{}/envs/{}'.format(dot_pkgenv, name))
    config_yaml_dict = get_config_yaml_as_dict()
    config_yaml_dict['custom_environment_paths'].append('{}/envs/{}'.format(dot_pkgenv, name))
    success = write_config_yaml_from_dict(config_yaml_dict)
    if not success: 
        print('ERROR: Failed to write new package environment path to {}'.format(config_yaml_path))
        return False

    add_package('pkgenv', name)
    add_package('which', name)
    add_package('readlink', name)
    add_package('dirname', name)
    if config_yaml_dict['preferred_editor']:
        add_package(config_yaml_dict['preferred_editor'], name)

    print('LOG: Created {}.'.format(name))
    return True


def open_config_yaml_file():
    if not does_config_yaml_exist():
        return False

    if not config_yaml_dict['preferred_editor']:
        print('WARN: You haven\'t set a preferred editor to open your config.yaml file!')
        ans = input('LOG: Would you prefer to use (V)im or (N)ano? ')
        while not ans.lower() in ['v', 'n']:
            ans = input('LOG: Would you prefer to use (V)im or (N)ano? ')

        if ans.lower() == 'v':
            config_yaml_dict['preferred_editor'] = 'vim'
        elif ans.lower() == 'n':
            config_yaml_dict['preferred_editor'] = 'nano'
        write_config_yaml_from_dict(config_yaml_dict)
    try:
        system('{} {}'.format(config_yaml_dict['preferred_editor'], config_yaml_path))
        config_yaml_dict = get_config_yaml_as_dict()
        for package_manager in config_yaml_dict['system_package_managers']:
            if not is_package_manager_supported(package_manager):
                print('WARN: Package manager `{}` is not supported with this release of pkgenv.'.format(package_manager))
    except:
        print('ERROR: Could not open {} using {}'.format(config_yaml_path, config_yaml_dict['preferred_editor']))
        return False
    return True


def change_path_in_bashrc(path):
    lines = []
    with open('{}/.bashrc'.format(user_home_path), 'r') as f:
        lines = f.readlines()
        updated_lines = []
        for line in lines:
            rewrite = sub(r'export PATH=.*', ''.format(path), line)
            updated_lines.append(rewrite)
        lines = updated_lines

    with open('{}/.bashrc'.format(user_home_path), 'w+') as f:
        f.write('{}export PATH={}'.format(''.join(updated_lines), path))


def switch_to_package_environment(name):
    if not name:
        print('ERROR: No named package environment to switch to.')
        return False
    
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return False

    if name == 'default':
        change_path_in_bashrc(config_yaml_dict['default_environment_path'])
        config_yaml_dict['active_package_environment'] = 'default_environment_path'
    else:
        if not does_package_environment_exist(name):
            print('ERROR: No such package environment `{}`.'.format(name))
            return False

        print('HINT: Your default PATH is {}. You can switch back by executing `pkgenv switch --name default`'.format(config_yaml_dict['default_environment_path']))
        change_path_in_bashrc('{}/envs/{}'.format(dot_pkgenv, name))
        config_yaml_dict['active_package_environment'] = '{}/envs/{}'.format(dot_pkgenv, name)

    write_config_yaml_from_dict(config_yaml_dict)
    print('LOG: Successfully switched package environment to {}.'.format(name))
    return True


def is_package_manager_supported(manager):
    supported_package_managers = ['apt-get', 'zypper', 'apk', 'pacman', 'pip', 'gem']
    return True if manager in supported_package_managers else False


def install_with_package_manager(manager, package):
    if not is_package_manager_supported(manager):
        print('ERROR: Package manager `{}` is not supported by this version of pkgenv.'.format(manager))
        return False

    success = False 
    print('LOG: Installing with `{}`'.format(manager)) 
    if manager == 'apt-get':
        success = True if system('apt-get install {}'.format(package)) else False
    elif manager == 'apk':
        success = True if system('apk add {}'.format(package)) else False
    elif manager == 'zypper':
        success = True if system('zypper install {}'.format(package)) else False
    elif manager == 'pacman':
        success = True if system('pacman -S {}'.format(package)) else False
    elif manager == 'pip':
        success = True if system('python3 -m pip install {}'.format(package)) else False
    elif manager == 'gem':
        success = True if system('gem install {}'.format(package)) else False

    return success


def add_package(package, pkgenv, manager=None):
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return False

    if not does_package_environment_exist(pkgenv):
        print('ERROR: No such package environment `{}`.'.format(pkgenv))
        return False

    active_package_environment = config_yaml_dict['active_package_environment']
    if not active_package_environment == 'default_environment_path':
        print('WARN: You are not currently in the default package environment. It is strongly recommended that you ' +
              'run this command with the default package environement active. Proceed at your own risk.')
        print('HINT: Execute `pkgenv switch --name default` to go back to the default package environment.')

    packages_managers = config_yaml_dict['system_package_managers']
    is_installed = True if system('which {}'.format(package)) == 0 else False

    if not is_installed and not manager:
        ans = input('LOG: No such package `{}`, would you like to install it? (Y/N) '.format(package))
        while ans.lower() not in ['y', 'n']:
            ans = input('LOG: No such package `{}`, would you like to install it? (Y/N) '.format(package))
        if ans == 'n':
            print('LOG: OK, will not install package `{}`.'.format(package))
            return True 
        elif ans == 'y':
            print('LOG: Known package managers: {}'.format(packages_managers))
            ans = input('LOG: Which package manager do you want to use to install `{}`? '.format(package))
            while ans not in packages_managers:
                print('LOG: Known package managers: {}'.format(packages_managers))
                ans = input('LOG: Which package manager do you want to use to install `{}`? '.format(package))
            
            install_with_package_manager(ans, package)

    elif not is_installed and manager:
        if manager not in packages_managers:
            print('ERROR: Package manager `{}` is unknown to pkgenv.'.format(manager))
            print('HINT: If you know that this manager is installed and is supported by pkgenv, you can add it to system_package_managers with `pkgenv config`.')
            return False
        
        install_with_package_manager(manager, package)
    
    print('LOG: `which {}`'.format(package))
    out, errs = Popen(['which', package], stdout=PIPE, stderr=PIPE).communicate()
    if errs:
        print('ERROR: An unexpected error occured: `{}`'.format(errs.decode('utf-8')))
        return False

    pkg_path = out.decode('utf-8').replace('\n', '')
    if path.exists(pkg_path):
        print('LOG: `Linking {} to {}/envs/{}`'.format(pkg_path, dot_pkgenv, pkgenv))
        success = system('ln -s {} {}/envs/{}'.format(pkg_path, dot_pkgenv, pkgenv))
        if success == 0:
            print('LOG: Successfully added `{}` to `{}`.'.format(package, pkgenv))
            return True
        else:
            print('ERROR: Failed to add `{}` to `{}`.'.format(package, pkgenv))
            return False
    else:
        print('ERROR: Cannot find package `{}`.'.format(package)) 
        return False 


def purge_package_environment(name):
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return False

    if not name:
        print('ERROR: No named package environment to purge.')
        return False

    if not does_package_environment_exist(name):
        print('ERROR: No such package environment `{}`.'.format(name))
        return False

    ans = input('WARN: Are you sure you want to purge your package environment? The package environment will be completely destroyed ' +
          'but all of the packages on your system will remain on disk. This operation is not reversible. (Y/N) ')
    while ans.lower() not in ['y', 'n']:
        ans = input('WARN: Are you sure you want to purge your environment? The environment will be completely removed from your system ' +
                    'but all of the packages on your system will remain on disk. (Y/N) ')
    if ans == 'n':
        print('LOG: OK, not purging `{}`.'.format(name))
    elif ans == 'y':
        print('LOG: Purging {}...'.format(name))
        environment_path = ''
        for env in config_yaml_dict['custom_environment_paths']:
            if name == env.split('/')[-1]:
                environment_path = env
                break

        if environment_path == config_yaml_dict['active_package_environment']:
            config_yaml_dict['active_package_environment'] = 'default_environment_path'

        config_yaml_dict['custom_environment_paths'].remove(environment_path)

        for root, dirs, files in walk(environment_path): # there should be no subdirs in the package environment
            for file in files:
                remove(path.join(root, file))
            break
        try:
            rmdir(environment_path)
        except FileNotFoundError():
            print('ERROR: Failed to delete directory `{}`. Directory does not exist.'.format(environment_path))
            return False
        except OSError():
            print('ERROR: Failed to delete directory `{}`. Directory not empty.'.format(environment_path))
            print('HINT: Something unexpected was found during the purge. Remove any subdirectories in your ' +
                  'environment and try again.')
            return False

        write_config_yaml_from_dict(config_yaml_dict)
        print('LOG: Successfully purged `{}`.'.format(name))
    return True


def get_active_package_environment():
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return None
    return config_yaml_dict['active_package_environment']


def update_default_environment_path_to_current_PATH():
    config_yaml_dict = get_config_yaml_as_dict()
    if not config_yaml_dict:
        return None
    config_yaml_dict['default_environment_path'] = environ['PATH']
    write_config_yaml_from_dict(config_yaml_dict)
    print('LOG: Updated default_environment_path to `{}`.'.format(config_yaml_dict['default_environment_path']))
    return config_yaml_dict['default_environment_path']


def remove_package_from_package_environment(package, pkgenv):
    if not does_package_environment_exist(pkgenv):
        print('ERROR: No such package environment `{}`.'.format(pkgenv))
        return False

    if not package:
        print('ERROR: No package to remove.')
        return False

    package_path = '{}/envs/{}/{}'.format(dot_pkgenv, pkgenv, package)
    try:
        remove(package_path)
    except FileNotFoundError():
        print('ERROR: No such package `{}` in `{}`.'.format(package, pkgenv))
        return False
    except OSError():
        print('ERROR: An unknown error occurred.')
        return False

    print('LOG: Successfully removed `{}` from `{}`.'.format(package, pkgenv))
    return True